<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Blade & Bone: Lock-On System</title>
    <style>
        :root { --ui-gold: #f1c40f; --ui-red: #c0392b; --ui-blue: #00d2ff; --ui-green: #2ecc71; }
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; user-select: none; touch-action: none; }
        #canvas-container { position: absolute; width: 100%; height: 100%; }
        #game-ui { position: absolute; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .stats-panel { position: absolute; top: 20px; left: 20px; width: 280px; pointer-events: auto; }
        .stat-row { margin-bottom: 12px; background: rgba(0,0,0,0.8); padding: 8px; border-left: 4px solid var(--ui-gold); }
        .bar-outer { width: 100%; height: 12px; background: #222; margin-top: 5px; border: 1px solid #444; overflow: hidden; }
        .bar-inner { height: 100%; transition: width 0.3s, background-color 0.2s; }
        #hp-bar { background: var(--ui-red); }
        .hp-heal { background-color: var(--ui-green) !important; }
        #joystick-wrapper { position: absolute; bottom: 50px; left: 50px; width: 150px; height: 150px; background: rgba(255,255,255,0.05); border-radius: 50%; border: 2px solid var(--ui-gold); pointer-events: auto; }
        #joystick-knob { position: absolute; top: 50%; left: 50%; width: 55px; height: 55px; background: var(--ui-gold); border-radius: 50%; transform: translate(-50%, -50%); }
        .action-cluster { position: absolute; bottom: 40px; right: 30px; display: flex; flex-direction: column; gap: 12px; pointer-events: auto; align-items: flex-end; }
        .action-btn { width: 75px; height: 75px; border-radius: 50%; border: 3px solid var(--ui-gold); background: rgba(0,0,0,0.8); color: white; font-weight: bold; display: flex; align-items: center; justify-content: center; font-size: 12px; }
        #btn-atk { width: 90px; height: 90px; background: rgba(192, 57, 43, 0.4); border-color: var(--ui-red); font-size: 14px; }
        #btn-ki { background: rgba(0, 210, 255, 0.4); border-color: var(--ui-blue); }
        #btn-lock { background: rgba(255, 255, 255, 0.1); border-color: #fff; height: 50px; border-radius: 10px; width: 100px; margin-bottom: 10px; }
        #screen-overlay { position: absolute; width: 100%; height: 100%; display: none; flex-direction: column; justify-content: center; align-items: center; background: rgba(0,0,0,0.9); z-index: 100; pointer-events: auto; }
    </style>
</head>
<body>
    <div id="game-ui">
        <div class="stats-panel">
            <div class="stat-row">
                <div style="color:white; font-size: 10px; text-transform: uppercase;">Vitality</div>
                <div class="bar-outer"><div id="hp-bar" class="bar-inner" style="width: 100%;"></div></div>
            </div>
            <div style="color:white; font-size: 12px; margin-top: 5px; font-weight: bold;">HOSTILES: <span id="enemy-count">0</span></div>
        </div>
        <div id="joystick-wrapper"><div id="joystick-knob"></div></div>
        <div class="action-cluster">
            <div class="action-btn" id="btn-lock">LOCK ON</div>
            <div class="action-btn" id="btn-ki">KI BLAST</div>
            <div class="action-btn" id="btn-atk">STRIKE</div>
        </div>
    </div>
    <div id="canvas-container"></div>
    <div id="screen-overlay"><button style="padding: 10px 20px; background: var(--ui-gold); border: none; font-weight: bold;" onclick="location.reload()">RE-ENTER ARENA</button></div>

    <script type="importmap"> { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } } </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>

    <script type="module">
        import * as THREE from 'three';

        const CONFIG = {
            gravity: -25, playerSpeed: 55, enemySpeed: 10,
            playerReach: 5.5, vanishDist: 60, camDist: 14,
            spawnRate: 2000, maxEnemies: 15, spawnDist: 60,
            healPerKill: 15
        };

        class Projectile {
            constructor(scene, pos, dir, color, isPlayerProj) {
                this.isPlayerProj = isPlayerProj;
                this.mesh = new THREE.Mesh(new THREE.IcosahedronGeometry(0.8, 1), new THREE.MeshBasicMaterial({color: 0xffffff, transparent:true, opacity:0.9}));
                this.mesh.add(new THREE.PointLight(color, 4, 15));
                this.mesh.position.copy(pos); this.dir = dir.normalize(); this.life = 2.5; this.active = true; scene.add(this.mesh);
            }
            update(dt) { 
                if(!this.active) return; 
                const speed = this.isPlayerProj ? 85 : 45;
                this.mesh.position.addScaledVector(this.dir, speed * dt); 
                this.life -= dt; if(this.life <= 0) this.destroy(); 
            }
            destroy() { this.active = false; this.mesh.visible = false; }
        }

        class Warrior {
            constructor(scene, world, color, isPlayer = false, onDeath = null) {
                this.scene = scene; this.world = world; this.color = color;
                this.isPlayer = isPlayer; this.hp = 100; this.isAtk = false; this.atkTime = 0; 
                this.dead = false; this.lastKiTime = 0; this.onDeath = onDeath;
                
                this.mesh = new THREE.Group();
                const torso = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.3, 0.7), new THREE.MeshStandardMaterial({ color, metalness: 0.6 }));
                torso.position.y = 1.9;
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.65, 0.65, 0.65), new THREE.MeshStandardMaterial({ color: 0xffdbac }));
                head.position.y = 2.8;
                this.rArm = new THREE.Group(); this.rArm.position.set(0.9, 2.3, 0);
                this.sword = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.15, 4.5, 6), new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: color, emissiveIntensity: 5 }));
                this.sword.rotation.x = Math.PI/2; this.sword.position.set(0,-1.2,1.8);
                this.rArm.add(new THREE.Mesh(new THREE.SphereGeometry(0.4, 8, 8), new THREE.MeshStandardMaterial({ color })), this.sword);
                this.mesh.add(torso, head, this.rArm); this.scene.add(this.mesh);
                
                this.body = new CANNON.Body({ mass: 70, fixedRotation: true, shape: new CANNON.Box(new CANNON.Vec3(0.6, 1.5, 0.6)) });
                this.world.addBody(this.body);
                if(isPlayer) this.body.position.set(0,5,0);
            }
            update(dt) {
                if(this.dead) return;
                this.mesh.position.set(this.body.position.x, this.body.position.y - 1.5, this.body.position.z);
                if(this.isAtk) {
                    this.atkTime += dt * 18; this.rArm.rotation.x = -Math.sin(this.atkTime)*2.5;
                    if(this.atkTime > Math.PI) { this.isAtk = false; this.atkTime = 0; this.rArm.rotation.x = 0; }
                }
                if(this.body.position.y < -20) this.takeDamage(100);
            }
            takeDamage(amt) {
                this.hp -= amt; 
                if(this.hp <= 0 && !this.dead) {
                    this.dead = true; 
                    if(this.onDeath) this.onDeath();
                    if(this.isPlayer) document.getElementById('screen-overlay').style.display='flex';
                    else { this.scene.remove(this.mesh); this.world.removeBody(this.body); }
                }
            }
            heal(amt) {
                this.hp = Math.min(100, this.hp + amt);
                const bar = document.getElementById('hp-bar');
                bar.classList.add('hp-heal');
                setTimeout(() => bar.classList.remove('hp-heal'), 200);
            }
        }

        class Game {
            constructor() {
                this.scene = new THREE.Scene(); this.world = new CANNON.World(); this.world.gravity.set(0, CONFIG.gravity, 0);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);
                this.camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
                this.camOrbit = { phi: 0.6, theta: 0 };
                
                this.lockTarget = null;
                this.lockMarker = new THREE.Mesh(new THREE.OctahedronGeometry(0.5, 0), new THREE.MeshBasicMaterial({color: 0xffffff}));
                this.scene.add(this.lockMarker);
                this.lockMarker.visible = false;

                const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 512;
                const ctx = canvas.getContext('2d'); ctx.fillStyle = '#1a1a1a'; ctx.fillRect(0,0,512,512);
                ctx.strokeStyle = '#444'; ctx.lineWidth = 4;
                for(let i=0; i<20; i++){ ctx.strokeRect(i*25,0,2,512); ctx.strokeRect(0,i*25,512,2); }
                const tex = new THREE.CanvasTexture(canvas);
                const arena = new THREE.Mesh(new THREE.CylinderGeometry(120, 125, 5, 64), new THREE.MeshStandardMaterial({ map: tex }));
                arena.position.y = -2.5; this.scene.add(arena);
                const groundBody = new CANNON.Body({ mass: 0 });
                groundBody.addShape(new CANNON.Cylinder(120, 125, 5, 64));
                const q = new CANNON.Quaternion(); q.setFromAxisAngle(new CANNON.Vec3(1,0,0), -Math.PI/2);
                groundBody.quaternion.copy(q); groundBody.position.set(0,-2.5,0); this.world.addBody(groundBody);

                this.scene.add(new THREE.AmbientLight(0xffffff, 0.8));
                const sun = new THREE.DirectionalLight(0xffffff, 1.2); sun.position.set(30,60,30); this.scene.add(sun);
                
                this.player = new Warrior(this.scene, this.world, 0x00ccff, true);
                this.enemies = []; this.projectiles = []; this.input = { joy:{x:0,y:0}, atk:false, ki:false };
                this.initControls(); this.clock = new THREE.Clock();
                setInterval(() => this.spawnEnemy(), CONFIG.spawnRate);
                this.loop();
            }
            spawnEnemy() {
                if(this.enemies.filter(e => !e.dead).length >= CONFIG.maxEnemies) return;
                const enemy = new Warrior(this.scene, this.world, 0xff2200, false, () => {
                    this.player.heal(CONFIG.healPerKill);
                    if(this.lockTarget === enemy) { this.lockTarget = null; this.lockMarker.visible = false; }
                });
                const a = Math.random() * Math.PI * 2;
                enemy.body.position.set(Math.cos(a)*CONFIG.spawnDist, 10, Math.sin(a)*CONFIG.spawnDist);
                this.enemies.push(enemy);
            }
            initControls() {
                const wrap = document.getElementById('joystick-wrapper');
                wrap.ontouchmove = (e) => {
                    const t = e.touches[0], r = wrap.getBoundingClientRect();
                    let dx = t.clientX-(r.left+75), dy = t.clientY-(r.top+75);
                    const d = Math.sqrt(dx*dx+dy*dy); if(d>70) { dx*=70/d; dy*=70/d; }
                    this.input.joy = { x: dx/70, y: dy/70 };
                };
                wrap.ontouchend = () => this.input.joy = {x:0,y:0};
                window.ontouchmove = (e) => {
                    if(!this.lockTarget && (e.touches.length > 1 || e.target.id === "canvas-container")) {
                        this.camOrbit.theta -= e.movementX * 0.005 || 0;
                        this.camOrbit.phi = Math.max(0.2, Math.min(1.3, this.camOrbit.phi + (e.movementY * 0.004 || 0)));
                    }
                };
                document.getElementById('btn-atk').ontouchstart = (e) => { e.preventDefault(); this.input.atk = true; };
                document.getElementById('btn-ki').ontouchstart = (e) => { e.preventDefault(); this.input.ki = true; };
                document.getElementById('btn-lock').ontouchstart = (e) => { 
                    e.preventDefault(); 
                    this.toggleLockOn();
                };
            }
            toggleLockOn() {
                if(this.lockTarget) { this.lockTarget = null; this.lockMarker.visible = false; return; }
                let best = null; let minD = Infinity;
                this.enemies.forEach(e => {
                    if(e.dead) return;
                    const d = e.mesh.position.distanceTo(this.player.mesh.position);
                    if(d < 60 && d < minD) { best = e; minD = d; }
                });
                this.lockTarget = best;
                if(this.lockTarget) this.lockMarker.visible = true;
            }
            loop() {
                requestAnimationFrame(() => this.loop());
                const dt = this.clock.getDelta(); this.world.step(1/60);
                const now = Date.now();

                // Lock-On Camera Logic
                if(this.lockTarget) {
                    const diff = new THREE.Vector3().subVectors(this.lockTarget.mesh.position, this.player.mesh.position);
                    this.camOrbit.theta = Math.atan2(diff.x, diff.z);
                    this.lockMarker.position.copy(this.lockTarget.mesh.position).y += 4;
                    this.lockMarker.rotation.y += dt * 5;
                    this.player.mesh.lookAt(this.lockTarget.mesh.position.x, this.player.mesh.position.y, this.lockTarget.mesh.position.z);
                }

                if(Math.abs(this.input.joy.x)>0.1 || Math.abs(this.input.joy.y)>0.1) {
                    const camF = new THREE.Vector3(0,0,-1).applyQuaternion(this.camera.quaternion); camF.y=0;
                    const camR = new THREE.Vector3().crossVectors(camF, new THREE.Vector3(0,1,0));
                    const move = new THREE.Vector3().addScaledVector(camR, this.input.joy.x).addScaledVector(camF, -this.input.joy.y);
                    if(!this.lockTarget) this.player.mesh.rotation.y = Math.atan2(move.x, move.z);
                    this.player.body.velocity.x = move.x*CONFIG.playerSpeed; this.player.body.velocity.z = move.z*CONFIG.playerSpeed;
                } else { this.player.body.velocity.x *= 0.5; this.player.body.velocity.z *= 0.5; }

                if(this.input.atk && !this.player.isAtk) {
                    this.input.atk = false; this.player.isAtk = true;
                    if(this.lockTarget) {
                        const b = new THREE.Vector3(0,0,-3).applyQuaternion(this.lockTarget.mesh.quaternion).add(this.lockTarget.mesh.position);
                        this.player.body.position.set(b.x, b.y + 1, b.z);
                    } else {
                        let target = null; let minDist = Infinity;
                        this.enemies.forEach(e => { if(!e.dead){ const d = this.player.mesh.position.distanceTo(e.mesh.position); if(d < CONFIG.vanishDist && d > 4 && d < minDist) { target = e; minDist = d; } } });
                        if(target) { const b = new THREE.Vector3(0,0,-3).applyQuaternion(target.mesh.quaternion).add(target.mesh.position); this.player.body.position.set(b.x, b.y + 1, b.z); this.player.mesh.lookAt(target.mesh.position); }
                    }
                    this.enemies.forEach(e => { if(!e.dead && this.player.mesh.position.distanceTo(e.mesh.position)<CONFIG.playerReach) e.takeDamage(40); });
                }

                if(this.input.ki) {
                    this.input.ki = false;
                    const dir = this.lockTarget ? new THREE.Vector3().subVectors(this.lockTarget.mesh.position, this.player.mesh.position).add(new THREE.Vector3(0,1.5,0)).normalize() : new THREE.Vector3(0,0,1).applyQuaternion(this.player.mesh.quaternion);
                    this.projectiles.push(new Projectile(this.scene, this.player.mesh.position.clone().add(new THREE.Vector3(0,1.5,0)), dir, 0x00ccff, true));
                }

                this.player.update(dt);
                this.projectiles.forEach(p => { 
                    if(p.active){ 
                        p.update(dt); 
                        if(p.isPlayerProj) { this.enemies.forEach(e => { if(!e.dead && p.mesh.position.distanceTo(e.mesh.position)<3) { e.takeDamage(30); p.destroy(); } }); } 
                        else { if(p.mesh.position.distanceTo(this.player.mesh.position)<2.5) { this.player.takeDamage(15); p.destroy(); } }
                    } 
                });

                const activeEnemies = this.enemies.filter(e => !e.dead);
                document.getElementById('enemy-count').innerText = activeEnemies.length;
                activeEnemies.forEach(e => {
                    e.update(dt); const d = e.mesh.position.distanceTo(this.player.mesh.position);
                    e.mesh.lookAt(this.player.mesh.position.x, e.mesh.position.y, this.player.mesh.position.z);
                    if(d < 6) { if(!e.isAtk && Math.random()<0.05) { e.isAtk=true; this.player.takeDamage(5); } } 
                    else if (d > 15 && now - e.lastKiTime > 3000 && Math.random() < 0.01) {
                        const dir = new THREE.Vector3().subVectors(this.player.mesh.position, e.mesh.position).normalize();
                        this.projectiles.push(new Projectile(this.scene, e.mesh.position.clone().add(new THREE.Vector3(0,1.5,0)), dir, 0xff2200, false));
                        e.lastKiTime = now;
                    } else { const v = new THREE.Vector3(0,0,1).applyQuaternion(e.mesh.quaternion); e.body.velocity.x=v.x*CONFIG.enemySpeed; e.body.velocity.z=v.z*CONFIG.enemySpeed; }
                });

                const pPos = this.player.mesh.position;
                this.camera.position.set(
                    pPos.x + CONFIG.camDist * Math.sin(this.camOrbit.phi) * Math.sin(this.camOrbit.theta),
                    pPos.y + CONFIG.camDist * Math.cos(this.camOrbit.phi),
                    pPos.z + CONFIG.camDist * Math.sin(this.camOrbit.phi) * Math.cos(this.camOrbit.theta)
                );
                this.camera.lookAt(pPos.x, pPos.y + 2, pPos.z);
                document.getElementById('hp-bar').style.width = this.player.hp + "%";
                this.renderer.render(this.scene, this.camera);
            }
        }
        window.onload = () => new Game();
    </script>
</body>
</html>
